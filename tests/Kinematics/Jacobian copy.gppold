#pragma once
// #define EIGEN_USE_BLAS ON
#define EIGEN_RUNTIME_NO_MALLOC ON
// #define ARDL_NO_VARIANT ON
#include "robotTestMain.cpp"
#include "Kinematics/common.hpp"
#include "ARDL/Util/Logger.hpp"
#include <chrono>

using namespace ARDL::Util;

TEST_CASE("Jacobian Checking", "[adjoint][kinematics]") {
    std::shared_ptr<KDL::ChainFkSolverPos_recursive> jnt_to_cart;
    std::shared_ptr<KDL::ChainJntToJacDotSolver> jnt_to_jacdot;
    std::shared_ptr<KDL::ChainJntToJacSolver> jnt_to_jac;

    std::shared_ptr<Chain<double> > c;
    std::shared_ptr<ForwardKinematics<double> > fk;

    pinocchio::Model pModel;
    pinocchio::Data pData;

    setupPinocchio(urdfModel, pModel, pData);

    setupARDL(urdfModel, c, fk);

    KDL::Chain chainKDL;
    setupKDL(urdfModel, chainKDL, jnt_to_cart, jnt_to_jacdot, jnt_to_jac, c->getRootName(), c->getTipName());

    std::shared_ptr<KDL::ChainFkSolverVel_recursive> jnt_to_vel = std::shared_ptr<KDL::ChainFkSolverVel_recursive>(new KDL::ChainFkSolverVel_recursive(chainKDL));

    #ifdef EIGEN_DONT_VECTORIZE
        RigidBodyDynamics::Model modelRBDL = setupRBDL(urdfModel);
    #endif
    Eigen::VectorXd q(c->getNumOfJoints());
    Eigen::VectorXd qd(c->getNumOfJoints()), qdd(c->getNumOfJoints());

    q.setZero();
    qd.setZero();
    qdd.setZero();

    Eigen::MatrixXd invAdj;
    invAdj.resize(6, 6);

    c->updateChain(q, qd);
    c->updateMatrices();

    aligned_vector<AdjointSE3<double> > adjoints;
    adjoints.resize(c->getNumOfJoints());
    fk->getAdjoints(adjoints);

    /******************KDL******************/
    KDL::JntArrayVel KDL_state(c->getNumOfJoints());
    KDL_state.resize(c->getNumOfJoints());
    KDL_state.q.data = q;
    KDL_state.qdot.data = qd;
    KDL::Frame cartPosFrame;
    jnt_to_cart->JntToCart(KDL_state.q, cartPosFrame, chainKDL.getNrOfSegments());
    KDL::Jacobian jac(c->getNumOfJoints());
    jnt_to_jac->JntToJac(KDL_state.q, jac, chainKDL.getNrOfSegments());
    KDL::Jacobian jacDot(c->getNumOfJoints());
    jnt_to_jacdot->setRepresentation(1);
    jnt_to_jacdot->JntToJacDot(KDL_state, jacDot, chainKDL.getNrOfSegments());

    /******************END KDL******************/

    aligned_vector<Jacobian<double> > jacobians, jacobianDots;
    jacobians.resize(c->getNumOfJoints());
    jacobianDots.resize(c->getNumOfJoints());
    for (int i = 0; i < c->getNumOfJoints(); i++) {
        jacobians.at(i).resize(c->getNumOfJoints());
        jacobians.at(i).setZero();
        jacobianDots.at(i).resize(c->getNumOfJoints());
        jacobianDots.at(i).setZero();
    }
    Jacobian<double> jacDL, jacDotDL;
    jacDL.resize(c->getNumOfJoints());
    jacDotDL.resize(c->getNumOfJoints());

    fk->getBodyJacobian(jacobians, jacobianDots);

    for (int i = 0; i < c->getNumOfJoints(); i++) {
        LOG_DEBUG_LEVEL5("DL JAC {}: \n {} \n\n", i, jacobians.at(i));
    }
    Eigen::Vector3d tmpP = adjoints.back().getPRef();
    adjoints.back().getPRef().setZero();

    fk->convertBodyToMixedJacobian(adjoints.back(), jacobians.back(), jacDL);
    LOG_DEBUG_LEVEL5("DL JAC: \n {} \n\n", jacDL);
    LOG_DEBUG_LEVEL5("KDL JAC: \n {} \n\n", jac.data);
    #ifdef EIGEN_DONT_VECTORIZE
        RigidBodyDynamics::UpdateKinematicsCustom(modelRBDL, &(q), NULL, NULL);
    #endif
    Eigen::Vector3d finalFixed;
    finalFixed.setZero();
    if (ARDL_visit(*c->getLinks().back()->getParentJoint(), isFixed())) {
        finalFixed = ARDL_visit(*c->getLinks().back()->getParentJoint(), getOriginTransform()).getR() * ARDL_visit(*c->getLinks().back()->getParentJoint(), getOriginTransform()).getP();
    }
    #ifdef EIGEN_DONT_VECTORIZE
        Eigen::MatrixXd jacobianRBDL, jacobianRBDLFlipped;
        jacobianRBDL.resize(c->getNumOfJoints());
        jacobianRBDLFlipped.resize(c->getNumOfJoints());
        jacobianRBDL.setZero();

        RigidBodyDynamics::CalcBodySpatialJacobian(modelRBDL, q, c->getNumOfJoints(), jacobianRBDL, true);

        // RigidBodyDynamics::CalcPointJacobian6D(modelRBDL, q, c->getNumOfJoints(), finalFixed, jacobianRBDL, true);

        jacobianRBDLFlipped.block(0, 0, 3, c->getNumOfJoints()) = jacobianRBDL.block(3, 0, 3, c->getNumOfJoints());
        jacobianRBDLFlipped.block(3, 0, 3, c->getNumOfJoints()) = jacobianRBDL.block(0, 0, 3, c->getNumOfJoints());

        LOG_DEBUG_LEVEL5("RBDL JAC: \n {} \n\n", jacobianRBDLFlipped);

        checkApproxMatrix(jacobianRBDLFlipped, jacDL);
    #endif
}

TEST_CASE("Jacobian Dot Checking", "[adjoint][kinematics]") {
    #if ARDL_VARIANT == ON
        std::cout << "RUNNING VARIANTS!" << std::endl;
    #else
        std::cout << "NO VARIANTS!" << std::endl;
    #endif
    std::shared_ptr<KDL::ChainFkSolverPos_recursive> jnt_to_cart;
    std::shared_ptr<KDL::ChainJntToJacDotSolver> jnt_to_jacdot;
    std::shared_ptr<KDL::ChainJntToJacSolver> jnt_to_jac;

    std::shared_ptr<Chain<double> > c;
    std::shared_ptr<ForwardKinematics<double> > fk;

    pinocchio::Model pModel;
    pinocchio::Data pData;

    setupPinocchio(urdfModel, pModel, pData);

    setupARDL(urdfModel, c, fk);

    KDL::Chain chainKDL;
    setupKDL(urdfModel, chainKDL, jnt_to_cart, jnt_to_jacdot, jnt_to_jac, c->getRootName(), c->getTipName());

    std::shared_ptr<KDL::ChainFkSolverVel_recursive> jnt_to_vel = std::shared_ptr<KDL::ChainFkSolverVel_recursive>(new KDL::ChainFkSolverVel_recursive(chainKDL));

    Eigen::VectorXd q(c->getNumOfJoints());
    Eigen::VectorXd qd(c->getNumOfJoints()), qdd(c->getNumOfJoints());

    q.setZero();
    qd.setZero();
    qdd.setZero();
    randomJointState(q, qd, qdd);

    Eigen::MatrixXd invAdj;
    invAdj.resize(6, 6);

    aligned_vector<AdjointSE3<double> > adjoints;
    adjoints.resize(c->getNumOfJoints());

    /******************KDL******************/
    KDL::JntArrayVel KDL_state(c->getNumOfJoints());
    KDL_state.q.data = q;
    KDL_state.qdot.data = qd;
    KDL::Jacobian jac(c->getNumOfJoints());

    KDL::Jacobian jacDot(c->getNumOfJoints());

    // jnt_to_jacdot->setRepresentation(1);
    using namespace std::chrono;
    std::cout << "STEADY? " << std::chrono::steady_clock::is_steady << std::endl;
    size_t iters = 1000;
    high_resolution_clock::time_point t1, t2;
    t1 = high_resolution_clock::now();

    for (size_t tmp1 = 0; tmp1 < iters; tmp1++) {
        jnt_to_jac->JntToJac(KDL_state.q, jac, chainKDL.getNrOfSegments());
        jnt_to_jacdot->JntToJacDot(KDL_state, jacDot, chainKDL.getNrOfSegments());
    }
    t2 = high_resolution_clock::now();

    duration<double> time_span = duration_cast<duration<double> >(t2 - t1) / (double)iters;

    std::cout << "It took KDL " << time_span.count() << " seconds.";
    std::cout << std::endl;

    /******************END KDL******************/

    aligned_vector<Jacobian<double> > jacobians, jacobianDots;
    jacobians.resize(c->getNumOfJoints());
    jacobianDots.resize(c->getNumOfJoints());
    for (int i = 0; i < c->getNumOfJoints(); i++) {
        jacobians.at(i).resize(c->getNumOfJoints());
        jacobians.at(i).setZero();
        jacobianDots.at(i).resize(c->getNumOfJoints());
        jacobianDots.at(i).setZero();
    }
    Jacobian<double> jacDL, jacDotDL;
    jacDL.resize(c->getNumOfJoints());
    jacDotDL.resize(c->getNumOfJoints());
    // t1 = steady_clock::now();
    // for (size_t tmp1 = 0; tmp1 < 100000; tmp1++) {
    //     c->updateChain(q, qd);
    // }
    // t2 = steady_clock::now();
    // time_span = duration_cast<duration<double> >((t2 - t1) / 100000);
    // std::cout << "It took ARDL " << time_span.count() << " seconds.";
    // std::cout << std::endl;
    // t1 = steady_clock::now();
    // for (size_t tmp1 = 0; tmp1 < 100000; tmp1++) {
    //     c->updateMatrices();
    // }
    // t2 = steady_clock::now();
    // time_span = duration_cast<duration<double> >((t2 - t1) / 100000);
    // std::cout << "It took ARDL " << time_span.count() << " seconds.";
    // std::cout << std::endl;
    // t1 = steady_clock::now();
    // for (size_t tmp1 = 0; tmp1 < 100000; tmp1++) {
    //     fk->getBodyJacobian(jacobians, jacobianDots);
    // }
    // t2 = steady_clock::now();
    // time_span = duration_cast<duration<double> >((t2 - t1) / 100000);
    // std::cout << "It took ARDL " << time_span.count() << " seconds.";
    // std::cout << std::endl;
    // t1 = steady_clock::now();
    // for (size_t tmp1 = 0; tmp1 < 100000; tmp1++) {
    //     fk->convertBodyToMixedJacobian(adjoints.back(), jacobians.back(), jacDL);
    // }
    // t2 = steady_clock::now();
    // time_span = duration_cast<duration<double> >((t2 - t1) / 100000);
    // std::cout << "It took ARDL " << time_span.count() << " seconds.";
    // std::cout << std::endl;
    // t1 = steady_clock::now();
    // for (size_t tmp1 = 0; tmp1 < 100000; tmp1++) {
    //     fk->convertBodyToMixedJacobianDot(adjoints.back(), jacDL, jacobianDots.back(), jacDotDL);
    // }
    // t2 = steady_clock::now();
    // time_span = duration_cast<duration<double> >((t2 - t1) / 100000);
    // std::cout << "It took ARDL " << time_span.count() << " seconds.";
    // std::cout << std::endl;

    Eigen::internal::set_is_malloc_allowed(false);

    t1 = high_resolution_clock::now();
    for (size_t tmp1 = 0; tmp1 < iters; tmp1++) {
        c->updateChain(q, qd);

        c->updateMatrices();

        fk->getBodyJacobianEE(jacobians.back(), jacobianDots.back());
    }
    t2 = high_resolution_clock::now();
    fk->getAdjoints(adjoints);

    fk->convertBodyToMixedJacobian(adjoints.back(), jacobians.back(), jacDL);
    // fk->convertBodyToMixedJacobian(adjoints.back(), jacobians.back(), jacDL);
    fk->convertBodyToMixedJacobianDot(adjoints.back(), jacDL, jacobianDots.back(), jacDotDL);
    Eigen::internal::set_is_malloc_allowed(true);
    // fk->convertBodyToMixedJacobian(adjoints.back(), jacobians.back(), jacDL);
    // fk->convertBodyToMixedJacobianDot(adjoints.back(), jacDL, jacobianDots.back(), jacDotDL);
    time_span = duration_cast<duration<double> >(t2 - t1) / (double)iters;
    std::cout << "It took ARDL " << time_span.count() << " seconds.";
    std::cout << std::endl;

    // for (size_t i = 0; i < c->getNumOfJoints(); i++) {
    //     LOG_DEBUG_LEVEL3("ARDL J {} {}", i, jacobians[i]);
    //     LOG_DEBUG_LEVEL3("ARDL JD {} {}", i, jacobianDots[i]);
    // }

    AdjointSE3<double> t = adjoints.back();
    LOG_DEBUG_LEVEL3("ARDLOPTIM AD \n{}", adjoints.back());
    LOG_DEBUG_LEVEL3("ARDLOPTIM J \n{}", jacobians.back());
    LOG_DEBUG_LEVEL3("ARDL J \n{}", jacobians.back());
    LOG_DEBUG_LEVEL3("KDL J \n{}", jac.data);
    LOG_DEBUG_LEVEL3("ARDL J \n{}\n\n", jacDL);
    checkApproxMatrix(jacDL, jac.data, 1e-10);

    // LOG_DEBUG_LEVEL3("ARDL JD {}", jacobianDots.back());

    LOG_DEBUG_LEVEL3("KDL JD\n {}", jacDot.data);
    LOG_DEBUG_LEVEL3("ARDL MJ JD\n {}", jacDotDL);
    // checkApproxMatrix(jacobianDots.back(), jacDot.data, 1e-10);

    // jnt_to_jacdot->setRepresentation(2);
    // jnt_to_jacdot->JntToJacDot(KDL_state, jacDot, chainKDL.getNrOfSegments());
    // jacDL = adjoints.back().getMatrix() * jacobians.back();
    // // fk->convertBodyToMixedJacobianDot(adjoints.back(), jacDL, jacobianDots.back(), jacDotDL);
    // LieBracketSE3<double> mt_bodyVelocity;
    // mt_bodyVelocity.getVelocity() = jacDL * qd;
    // mt_bodyVelocity.calcMatrix();

    // jacDotDL = adjoints.back().getMatrix() * jacobianDots.back() + mt_bodyVelocity.getMatrix() * jacDL;

    LOG_DEBUG_LEVEL3("ARDL JD\n {}\n", jacobianDots.back());

    fk->getBodyJacobian(jacobians, jacobianDots);
    for (size_t i = 0; i < 7; i++) {
        LOG_DEBUG_LEVEL3("ARDL JD {}\n {}\n", i, jacobianDots[i]);
    }

    KDL::Frame kdlFrame;
    kdlFrame.p.data[0] = adjoints.back().getP()(0);
    kdlFrame.p.data[1] = adjoints.back().getP()(1);
    kdlFrame.p.data[2] = adjoints.back().getP()(2);

    jac.changeRefPoint(-kdlFrame.p);
    LOG_DEBUG_LEVEL3("Inertial KDL J \n{}", jac.data);
    fk->getInertialJacobian(jacobians.back(), jacobianDots.back());
    LOG_DEBUG_LEVEL3("Inertial ARDL J \n{}", jacobians.back());

    jnt_to_jacdot->setRepresentation(2);
    jnt_to_jacdot->JntToJacDot(KDL_state, jacDot, chainKDL.getNrOfSegments());
    LOG_DEBUG_LEVEL3("Inertial KDL JD \n{}", jacDot.data);
    LOG_DEBUG_LEVEL3("Inertial ARDL JD \n{}", jacobianDots.back());
    t1 = high_resolution_clock::now();

    for (size_t tmp1 = 0; tmp1 < iters; tmp1++) {
        c->updateChain(q, qd);

        c->updateMatrices();
        fk->getInertialJacobians(jacobians, jacobianDots);
    }
    t2 = high_resolution_clock::now();
    time_span = duration_cast<duration<double> >(t2 - t1) / (double)iters;
    std::cout << "It took ARDL " << time_span.count() << " seconds.";
    std::cout << std::endl;
    for (size_t i = 0; i < 7; i++) {
        jnt_to_jacdot->JntToJacDot(KDL_state, jacDot, i + 1);
        LOG_DEBUG_LEVEL3("Inertial KDL JD \n{}", jacDot.data);
        LOG_DEBUG_LEVEL3("Inertial ARDL JD \n{}", jacobianDots[i]);
    }

    // LOG_DEBUG_LEVEL3("KDL JD\n {}", jacDot.data);

    // checkApproxMatrix(jacDotDL, jacDot.data, 1e-10);

    // jnt_to_jac->JntToJac(KDL_state.q, jac, chainKDL.getNrOfSegments());
    // jnt_to_jacdot->setRepresentation(0);
    // jnt_to_jacdot->JntToJacDot(KDL_state, jacDot, chainKDL.getNrOfSegments());

    // t1 = steady_clock::now();
    // fk->getBodyJacobian(jacobians, jacobianDots);
    // fk->convertBodyToMixedJacobian(adjoints.back(), jacobians.back(), jacDL);
    // fk->convertBodyToMixedJacobianDot(adjoints.back(), jacDL, jacobianDots.back(), jacDotDL);
    // t2 = steady_clock::now();
    // time_span = duration_cast<duration<double> >(t2 - t1);
    // std::cout << "It took me " << time_span.count() << " seconds.";
    // std::cout << std::endl;
    // LOG_DEBUG_LEVEL3("ARDL JD {}", jacDotDL);

    // LOG_DEBUG_LEVEL3("KDL JD {}", jacDot.data);

    // checkApproxMatrix(jacDotDL, jacDot.data, 1e-10);
    // {
    //     int degree = 5;
    //     int N = degree + 1;
    //     double a = -M_PI;
    //     double b = M_PI;

    //     Eigen::ArrayXd t = Eigen::ArrayXd::LinSpaced(N, 0, N - 1);
    //     t += 0.5;
    //     t /= N;

    //     std::cout << t.transpose() << std::endl;
    //     t *= M_PI;
    //     t = -t.cos();

    //     std::cout << t.transpose() << std::endl;
    //     Eigen::ArrayXd x = (t * (b - a) + (b + a)) / 2;

    //     std::cout << x.transpose() << std::endl;
    //     Eigen::ArrayXd y = x.sin();
    //     Eigen::MatrixXd T; T.resize(N, N);
    //     T.col(0).setOnes();
    //     T.col(1) = t;
    //     for (size_t i = 2; i < N; i++) {
    //         T.col(i) = (2 * t * T.col(i - 1).array() - T.col(i - 2).array()).matrix();
    //     }
    //     std::cout << "y:" << std::endl << y << std::endl << "T: " << std::endl << T << std::endl << std::endl;
    //     Eigen::MatrixXd tmp = y;
    //     std::cout << "tmp1:" << tmp << std::endl;
    //     tmp = tmp.adjoint() * T;
    //     std::cout << "tmp2:" << tmp.array() << std::endl;
    //     std::cout << "tmp3: " << (2.0 / N) * tmp << std::endl;
    //     Eigen::ArrayXd c1 = ((2.0 / N) * tmp.transpose());

    //     std::cout << "c1:" << c1.transpose() << std::endl;
    //     c1[0] /= 2;
    //     std::cout << c1 << std::endl;
    //     Eigen::ArrayXd test(1);
    //     test[0] = ((double)rand() / (RAND_MAX));
    //     std::cout << test << std::endl;
    //     test *= b;
    //     std::cout << test.sin() << std::endl;
    //     std::cout << test << std::endl;
    //     Eigen::ArrayXd u = (test - ((a + b) / 2.0)) / ((b - a) / 2.0);
    //     Eigen::ArrayXd Tprev = Eigen::ArrayXd::Ones(10);
    //     Eigen::ArrayXd out = c1[0] * Tprev;
    //     Eigen::ArrayXd T1(1), T2(1);

    //     Tprev = Eigen::ArrayXd::Ones(1);
    //     t1 = high_resolution_clock::now();
    //     u = (test - ((a + b) / 2.0)) / ((b - a) / 2.0);
    //     out = c1[0] * Tprev;
    //     out += u * c1[1];
    //     T1 = u, T2 = u;
    //     for (size_t i = 2; i < N; i++) {
    //         T2 = 2 * u * T1 - Tprev;
    //         Tprev = T1;
    //         T1 = T2;
    //         out += T1 * c1[i];
    //     }
    //     t2 = high_resolution_clock::now();
    //     time_span = duration_cast<duration<double> >(t2 - t1);
    //     std::cout << "It took fastsine " << time_span.count() << " seconds.";
    //     std::cout << std::endl;
    //     t1 = high_resolution_clock::now();
    //     sin(test[0]);
    //     t2 = high_resolution_clock::now();
    //     time_span = duration_cast<duration<double> >(t2 - t1);
    //     std::cout << "It took sine " << time_span.count() << " seconds.";
    //     std::cout << std::endl;
    //     double wiki = -1;
    //     t1 = high_resolution_clock::now();
    //     wiki = (383.0 / 384.0) * test[0] - (5.0 / 32.0) * (test[0] * test[0] * test[0]);
    //     t2 = high_resolution_clock::now();
    //     time_span = duration_cast<duration<double> >(t2 - t1);
    //     std::cout << "It took sine " << time_span.count() << " seconds.";
    //     std::cout << std::endl;
    //     std::cout << out.transpose() << std::endl;
    //     std::cout << test.sin().transpose() << std::endl;
    //     std::cout << (383.0 / 384.0) * test[0] - (5.0 / 32.0) * (test[0] * test[0] * test[0]) << std::endl;
    //     std::cout << wiki << std::endl;
    // }
    pinocchio::Data::Matrix6x J(6, pModel.nv); J.setZero();
    t1 = high_resolution_clock::now();
    for (size_t tmp1 = 0; tmp1 < iters; tmp1++) {
        pinocchio::computeJointJacobian(pModel, pData, q, 7, J);
    }
    t2 = high_resolution_clock::now();
    time_span = duration_cast<duration<double> >(t2 - t1) / (double)iters;
    std::cout << "It took Pinocchio " << time_span.count() << " seconds.";
    std::cout << std::endl;
    LOG_DEBUG_LEVEL3("Pinocchio J \n{}", J);

    LieBracketSE3<double> tmp1;
    tmp1.getVelocity() << 1, 2, 3, 4, 5, 6;
    LieBracketSE3<double> tmp2, tmp4;
    tmp2.getVelocity() << 6, 5, 4, 3, 2, 1;
    // tmp4.getVelocity().template head<3>() = tmp1.getVelocity().template head<3>().template cross(tmp2.getVelocity().template head<3>());
    // tmp4.getVelocity().template head<3>() = tmp1.getVelocity().template tail<3>().template cross(tmp2.getVelocity().template head<3>()) + tmp1.getVelocity().template head<3>().cross(tmp2.getVelocity().template tail<3>());
    tmp1.calcMatrix();
    tmp2.calcMatrix();
    tmp4.getVelocity() = tmp2.getMatrix() * tmp1.getVelocity();
    tmp4.calcMatrix();
    std::cout << std::endl << std::endl << tmp1.getVelocity() + tmp2.getVelocity() + Eigen::Matrix<double, 6, 1>::Zero() << std::endl;

    std::cout << std::endl << std::endl << tmp4.getVelocity() + Eigen::Matrix<double, 6, 1>::Zero() << std::endl;
    std::cout << std::endl << tmp1.getMatrix() << std::endl;
    std::cout << std::endl << tmp2.getMatrix() << std::endl;
}
