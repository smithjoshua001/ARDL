#pragma once

#include "ARDL/typedefs.hpp"
#include "ARDL/Model/Chain.hpp"

namespace ARDL {
    using namespace Model;
    using namespace Math;
    template <typename T> class ForwardKinematicsOptim {
    private:
        std::shared_ptr<Chain<T> > m_chain;

        fcl::CollisionRequest<T> mt_request;
        fcl::CollisionResult<T> mt_result;

        Eigen::Matrix<T, 6, 36> mt_W;

        /**************TEMPORARIES**************/
        AdjointSE3<T> mt_accumulatorLocal, mt_accumulatorGlobal;
        LieBracketSE3<T> mt_bodyVelocity, mt_bodyVelocity2;

        Jacobian<T> mt_jacobian, mt_jacobianDot;

    public:

        EIGEN_MAKE_ALIGNED_OPERATOR_NEW;

        ForwardKinematics(std::shared_ptr<Chain<T> > chain) {
            this->m_chain = chain;
            mt_jacobian.resize(6, chain->getNumOfJoints());
            mt_jacobianDot.resize(6, chain->getNumOfJoints());
            Eigen::Matrix<T, 3, 3> iden33;
            iden33.setIdentity();
            Eigen::Matrix<T, 3, 6 * 3> Ww;
            Ww.setZero();
            Ww.template block<1, 3>(1, 3) = iden33.template block<1, 3>(2, 0);
            Ww.template block<1, 3>(2, 3) = -iden33.template block<1, 3>(1, 0);
            Ww.template block<1, 3>(0, 9) = -iden33.template block<1, 3>(2, 0);
            Ww.template block<1, 3>(2, 9) = iden33.template block<1, 3>(0, 0);
            Ww.template block<1, 3>(0, 15) = iden33.template block<1, 3>(1, 0);
            Ww.template block<1, 3>(1, 15) = -iden33.template block<1, 3>(0, 0);

            Eigen::Matrix<T, 3, 6 * 3> Wv;
            Wv.setZero();
            Wv.template block<1, 3>(1, 0) = iden33.template block<1, 3>(2, 0);
            Wv.template block<1, 3>(2, 0) = -iden33.template block<1, 3>(1, 0);
            Wv.template block<1, 3>(0, 6) = -iden33.template block<1, 3>(2, 0);
            Wv.template block<1, 3>(2, 6) = iden33.template block<1, 3>(0, 0);
            Wv.template block<1, 3>(0, 12) = iden33.template block<1, 3>(1, 0);
            Wv.template block<1, 3>(1, 12) = -iden33.template block<1, 3>(0, 0);

            mt_W.setZero();
            mt_W.template block<3, 18>(0, 0) = Wv;
            mt_W.template block<3, 18>(3, 18) = Wv;
            mt_W.template block<3, 18>(3, 0) = Ww;
        }

        void getAdjoints(aligned_vector<AdjointSE3<T> > &ATs, bool update_collision = false) {
            size_t j = 0;
            ATs.at(0).setIdentity();
            for (std::shared_ptr<Link<T> > &link: m_chain->getMovableLinks()) {
                size_t index = std::min(j, ATs.size() - 1);

                if (!link->isRoot()) {
                    link->getParentJoint()->getAdjointLocal().apply(ATs.at(index), ATs.at(index));
                }
                if (update_collision) {
                    link->updateCollision(ATs.at(index));
                }
            }
            assert(j == m_chain->getNumOfJoints());
        }

        void getInverseAdjoints(aligned_vector<AdjointSE3<T> > &ATs, bool update_collision = false) {
            size_t j = 0;
            ATs.at(0).setIdentity();
            for (std::shared_ptr<Link<T> > &link: m_chain->getMovableLinks()) {
                size_t index = std::min(j, ATs.size() - 1);
                if (!link->isRoot()) {
                    link->getParentJoint()->getAdjointLocal().applyInverseTo(ATs[index], ATs[index]);
                    ATs[std::min(j + 1, ATs.size() - 1)] = ATs[index];
                    j++;
                }
            }
            assert(j == m_chain->getNumOfJoints());
        }

        void getLieBrackets(aligned_vector<LieBracketSE3<T> > &adjs, aligned_vector<Jacobian<T> > &jacobians) {
            size_t j = 0;
            for (Jacobian<T> &jacobian: jacobians) {
                adjs[j].setVelocity(jacobian.block(0, 0, 6, j + 1) * m_chain->getQd());
                j++;
            }
        }

        void getBodyJacobian(aligned_vector<Jacobian<T> > &jacobian, aligned_vector<Jacobian<T> > &jacobianDot) {
            mt_accumulatorLocal.setIdentity();
            size_t j = 0;
            jacobian.at(j).setZero();
            jacobianDot.at(j).setZero();

            for (std::shared_ptr<Link<T> > &link: m_chain->getLinksRef()) {
                if (!link->isRoot() && !link->getParentJoint()->isFixed()) {
                    size_t index = std::max((int)j - 1, 0);
                    jacobian.at(j).setZero();
                    for (int l = 0; l < j; l++) {
                        link->getParentJoint()->getAdjointLocal().applyInverse(jacobian.at(index).template block<6, 1>(0, l), jacobian.at(j).template block<6, 1>(0, l));
                        mt_accumulatorLocal.applyInverse(jacobian.at(j).template block<6, 1>(0, l), jacobian.at(j).template block<6, 1>(0, l));
                    }

                    jacobianDot.at(j).setZero();
                    for (int l = 0; l < j; l++) {
                        link->getParentJoint()->getAdjointLocal().applyInverse(jacobianDot.at(index).template block<6, 1>(0, l), jacobianDot.at(j).template block<6, 1>(0, l));
                        mt_accumulatorLocal.applyInverse(jacobianDot.at(j).template block<6, 1>(0, l), jacobianDot.at(j).template block<6, 1>(0, l));
                    }

                    mt_bodyVelocity.getVelocity().setZero();
                    mt_accumulatorLocal.applyInverse(link->getParentJoint()->getVelocityVector(), mt_bodyVelocity.getVelocity());
                    mt_bodyVelocity.calcMatrix();
                    jacobianDot.at(j) = jacobianDot.at(j) - (mt_bodyVelocity.getMatrix() * jacobian.at(j));
                    mt_accumulatorLocal.apply(link->getParentJoint()->getS(), jacobian.at(j).template block<6, 1>(0, j));

                    mt_accumulatorLocal.setIdentity();

                    j++;
                } else if (!link->isRoot() && link->getParentJoint()->isFixed()) {
                    link->getParentJoint()->getAdjointLocal().apply(mt_accumulatorLocal, mt_accumulatorLocal);
                }
            }
            assert(j == m_chain->getNumOfJoints());

            for (int l = 0; l < j; l++) {
                mt_accumulatorLocal.applyInverse(jacobian.at(j - 1).template block<6, 1>(0, l), jacobian.at(j - 1).template block<6, 1>(0, l));
                mt_accumulatorLocal.applyInverse(jacobianDot.at(j - 1).template block<6, 1>(0, l), jacobianDot.at(j - 1).template block<6, 1>(0, l));
            }
        }

        void convertBodyToMixedJacobian(const AdjointSE3<T> &adjointTransform, const Jacobian<T> &b_jacobian, Jacobian<T> &m_jacobian) {
            mt_accumulatorLocal = adjointTransform;
            mt_accumulatorLocal.getPRef().setZero();

            m_jacobian = mt_accumulatorLocal.getMatrix() * b_jacobian;
        }

        void convertBodyToMixedJacobianDot(const AdjointSE3<T> &adjointTransform, const Jacobian<T> &m_jacobian, const Jacobian<T> &b_jacobianDot, Jacobian<T> &m_jacobianDot) {
            mt_accumulatorLocal = adjointTransform;
            mt_accumulatorLocal.getPRef().setZero();

            mt_bodyVelocity.getVelocity().template head<3>().setZero();
            mt_bodyVelocity.getVelocity().template tail<3>() = m_jacobian.template block(3, 0, 3, m_chain->getNumOfJoints()) * m_chain->getQd();
            mt_bodyVelocity.calcMatrix();

            m_jacobianDot = mt_accumulatorLocal.getMatrix() * b_jacobianDot + mt_bodyVelocity.getMatrix() * m_jacobian;
        }

        template <int k> void convertBodyToMixedJacobiansDq(const aligned_vector<AdjointSE3<T> > &adjointTransforms, const Jacobian<T> &m_jacobian, const aligned_vector<Jacobian<T> > &b_jacobiansDQ, aligned_vector<Jacobian<T> > &m_jacobiansDQ) {
            for (size_t index = 0; index < m_chain->getNumOfJoints(); index++) {
                mt_accumulatorLocal = adjointTransforms.back();
                mt_accumulatorLocal.getPRef().setZero();
                mt_bodyVelocity.getVelocity() = m_jacobian.col(index);

                mt_bodyVelocity.getVelocity().template head<3>().setZero();
                mt_bodyVelocity.calcMatrix();
                m_jacobiansDQ[index] = mt_accumulatorLocal.getMatrix() * b_jacobiansDQ[index] + mt_bodyVelocity.getMatrix() * m_jacobian;
            }
        }

        template <int k> void convertBodyToMixedJacobiansDotDq(const aligned_vector<AdjointSE3<T> > &adjointTransforms,
                                                               const Jacobian<T> &b_jacobian,
                                                               const aligned_vector<Jacobian<T> > &b_jacobiansDQ,
                                                               const Jacobian<T> &b_jacobianDot,
                                                               const aligned_vector<Jacobian<T> > &b_jacobiansDotDQ,
                                                               aligned_vector<Jacobian<T> > &m_jacobiansDotDQ) {
            for (size_t index = 0; index < m_chain->getNumOfJoints(); index++) {
                mt_accumulatorLocal = adjointTransforms.back();
                mt_bodyVelocity.getVelocity() = b_jacobian.col(index);
                mt_bodyVelocity.getVelocity().template head<3>().setZero();
                mt_bodyVelocity.calcMatrix();
                mt_accumulatorLocal.getPRef().setZero();

                m_jacobiansDotDQ[index] = mt_accumulatorLocal.getMatrix() * b_jacobiansDotDQ[index] + mt_accumulatorLocal.getMatrix() * mt_bodyVelocity.getMatrix() * b_jacobianDot;

                mt_bodyVelocity2.getVelocity().template head<3>().setZero();
                mt_bodyVelocity2.getVelocity().template tail<3>() = b_jacobian.template block(3, 0, 3, m_chain->getNumOfJoints()) * m_chain->getQd();
                mt_bodyVelocity2.calcMatrix();

                m_jacobiansDotDQ[index] += mt_accumulatorLocal.getMatrix() * mt_bodyVelocity2.getMatrix() * b_jacobiansDQ[index] + mt_accumulatorLocal.getMatrix() * mt_bodyVelocity.getMatrix() * mt_bodyVelocity2.getMatrix() * b_jacobian;

                mt_bodyVelocity2.getVelocity().template head<3>().setZero();
                mt_bodyVelocity2.getVelocity().template tail<3>() = b_jacobiansDQ[index].template block(3, 0, 3, m_chain->getNumOfJoints()) * m_chain->getQd();
                mt_bodyVelocity2.calcMatrix();

                m_jacobiansDotDQ[index] += mt_accumulatorLocal.getMatrix() * mt_bodyVelocity2.getMatrix() * b_jacobian;
            }
        }

        template <int k> void getBodyJacobianEEStateDerivative(const aligned_vector<Jacobian<T> > &body_jacobian,
                                                               const aligned_vector<Jacobian<T> > &body_jacobianDot,
                                                               aligned_vector<Jacobian<T> > &body_jacobianDq,
                                                               aligned_vector<Jacobian<T> > &body_jacobianDotDq) {
            mt_accumulatorLocal.setIdentity();
            size_t j = 0;
            for (size_t j0 = 0; j0 < m_chain->getNumOfJoints(); j0++) {
                body_jacobianDq[j0].setZero();
                body_jacobianDotDq[j0].setZero();
            }
            mt_jacobian.setZero();
            mt_jacobianDot.setZero();

            for (std::shared_ptr<Link<T> > &link: m_chain->getLinksRef()) {
                if (!link->isRoot() && !link->getParentJoint()->isFixed()) {
                    size_t index = std::max((int)j - 1, 0);
                    link->getParentJoint()->getAdjointLocal().apply(mt_accumulatorLocal, mt_accumulatorLocal);

                    for (size_t j0 = 0; j0 < m_chain->getNumOfJoints(); j0++) {
                        for (int l = 0; l < j; l++) {
                            mt_accumulatorLocal.applyInverse(body_jacobianDq[j0].template block<6, 1>(0, l), body_jacobianDq[j0].template block<6, 1>(0, l));
                            mt_accumulatorLocal.applyInverse(body_jacobianDotDq[j0].template block<6, 1>(0, l), body_jacobianDotDq[j0].template block<6, 1>(0, l));
                        }
                    }
                    if (j - 1 >= 0) {
                        for (int l = 0; l < j; l++) {
                            mt_accumulatorLocal.applyInverse(body_jacobian.at(index).template block<6, 1>(0, l), mt_jacobian.template block<6, 1>(0, l));
                            mt_accumulatorLocal.applyInverse(body_jacobianDot.at(index).template block<6, 1>(0, l), mt_jacobianDot.template block<6, 1>(0, l));
                        }
                    }

                    //create adjunct
                    mt_bodyVelocity.setVelocity(m_chain->getJoint(j)->getS());

                    body_jacobianDq[j] -= mt_bodyVelocity.getMatrix() * mt_jacobian;

                    body_jacobianDotDq[j] -= mt_bodyVelocity.getMatrix() * mt_jacobianDot;

                    for (size_t j0 = 0; j0 < m_chain->getNumOfJoints(); j0++) {
                        body_jacobianDotDq[j0] -= link->getParentJoint()->getAdjPK() * body_jacobianDq[j0];
                    }

                    mt_accumulatorLocal.setIdentity();

                    j++;
                } else if (!link->isRoot() && link->getParentJoint()->isFixed()) {
                    link->getParentJoint()->getAdjointLocal().apply(mt_accumulatorLocal, mt_accumulatorLocal);
                }
            }
            assert(j == m_chain->getNumOfJoints());
            for (size_t j0 = 0; j0 < m_chain->getNumOfJoints(); j0++) {
                for (int l = 0; l < j; l++) {
                    mt_accumulatorLocal.applyInverse(body_jacobianDq[j0].template block<6, 1>(0, l), body_jacobianDq[j0].template block<6, 1>(0, l));
                    mt_accumulatorLocal.applyInverse(body_jacobianDotDq[j0].template block<6, 1>(0, l), body_jacobianDotDq[j0].template block<6, 1>(0, l));
                }
            }
        }
        template <int k> void getBodyJacobianStateDerivatives(const aligned_vector<Jacobian<T> > &body_jacobian,
                                                              const aligned_vector<Jacobian<T> > &body_jacobianDot,
                                                              aligned_vector<aligned_vector<Jacobian<T> > > &body_jacobianDq,
                                                              aligned_vector<aligned_vector<Jacobian<T> > > &body_jacobianDotDq) {
            mt_accumulatorLocal.setIdentity();
            size_t j = 0;
            for (size_t j0 = 0; j0 < m_chain->getNumOfJoints(); j0++) {
                for (size_t j1 = 0; j1 < m_chain->getNumOfJoints(); j1++) {
                    body_jacobianDq[j0][j1].setZero();
                    body_jacobianDotDq[j0][j1].setZero();
                }
            }
            mt_jacobian.setZero();
            mt_jacobianDot.setZero();

            for (std::shared_ptr<Link<T> > &link: m_chain->getLinksRef()) {
                if (!link->isRoot() && !link->getParentJoint()->isFixed()) {
                    size_t index = std::max((int)j - 1, 0);
                    link->getParentJoint()->getAdjointLocal().apply(mt_accumulatorLocal, mt_accumulatorLocal);

                    for (size_t j0 = 0; j0 < m_chain->getNumOfJoints(); j0++) {
                        for (int l = 0; l < j; l++) {
                            mt_accumulatorLocal.applyInverse(body_jacobianDq[index][j0].template block<6, 1>(0, l), body_jacobianDq[j][j0].template block<6, 1>(0, l));
                            mt_accumulatorLocal.applyInverse(body_jacobianDotDq[index][j0].template block<6, 1>(0, l), body_jacobianDotDq[j][j0].template block<6, 1>(0, l));
                        }
                    }
                    if (j - 1 >= 0) {
                        for (int l = 0; l < j; l++) {
                            mt_accumulatorLocal.applyInverse(body_jacobian[index].template block<6, 1>(0, l), mt_jacobian.template block<6, 1>(0, l));
                            mt_accumulatorLocal.applyInverse(body_jacobianDot[index].template block<6, 1>(0, l), mt_jacobianDot.template block<6, 1>(0, l));
                        }
                    }

                    //create adjunct
                    mt_bodyVelocity.setVelocity(m_chain->getJoint(j)->getS());

                    body_jacobianDq[j][j] -= mt_bodyVelocity.getMatrix() * mt_jacobian;

                    body_jacobianDotDq[j][j] -= mt_bodyVelocity.getMatrix() * mt_jacobianDot;

                    for (size_t j0 = 0; j0 < m_chain->getNumOfJoints(); j0++) {
                        body_jacobianDotDq[j][j0] -= link->getParentJoint()->getAdjPK() * body_jacobianDq[j][j0];
                    }

                    mt_accumulatorLocal.setIdentity();

                    j++;
                } else if (!link->isRoot() && link->getParentJoint()->isFixed()) {
                    link->getParentJoint()->getAdjointLocal().apply(mt_accumulatorLocal, mt_accumulatorLocal);
                }
            }
            assert(j == m_chain->getNumOfJoints());
            for (size_t j0 = 0; j0 < m_chain->getNumOfJoints(); j0++) {
                for (int l = 0; l < j; l++) {
                    mt_accumulatorLocal.applyInverse(body_jacobianDq[j - 1][j0].template block<6, 1>(0, l), body_jacobianDq[j - 1][j0].template block<6, 1>(0, l));
                    mt_accumulatorLocal.applyInverse(body_jacobianDotDq[j - 1][j0].template block<6, 1>(0, l), body_jacobianDotDq[j - 1][j0].template block<6, 1>(0, l));
                }
            }
        }

        size_t number_of_collision_checks() {
            size_t collision_no = 0;
            for (size_t i = 0; i < m_chain->getLinks().size(); i++) {
                for (size_t j = i + 2; j < m_chain->getLinks().size(); j++) {
                    if (m_chain->getLinks().data()[j]->hasCollision()) {
                        collision_no++;
                    }
                }
            }
            return collision_no;
        }

        bool collision() {
            int collision_no = 0;
            for (size_t i = 0; i < m_chain->getLinks().size(); i++) {
                fcl::CollisionObject<float> *obj1 = m_chain->getLinks().data()[i]->getCollisionObjectPtr().get();
                for (size_t j = i + 2; j < m_chain->getLinks().size(); j++) {  //5 4 3 2 1
                    if (m_chain->getLinks().data()[j]->hasCollision()) {
                        fcl::CollisionObject<float> *obj2 = m_chain->getLinks().data()[j]->getCollisionObjectPtr().get();
                        collide(obj1, obj2, mt_request, mt_result);
                        if (mt_result.isCollision()) {
                            mt_result.clear();
                            return true;
                        }
                        collision_no++;
                    }
                }
            }
            return false;
        }
        int collision_number() {
            int collision_no = 0;
            for (size_t i = 0; i < m_chain->getLinks().size(); i++) {
                fcl::CollisionObject<float> *obj1 = m_chain->getLinks().data()[i]->getCollisionObjectPtr().get();
                for (size_t j = i + 2; j < m_chain->getLinks().size(); j++) {  //5 4 3 2 1
                    if (m_chain->getLinks().data()[j]->hasCollision()) {
                        fcl::CollisionObject<float> *obj2 = m_chain->getLinks().data()[j]->getCollisionObjectPtr().get();
                        collide(obj1, obj2, mt_request, mt_result);
                        if (mt_result.isCollision()) {
                            mt_result.clear();
                            collision_no++;
                        }
                    }
                }
            }
            return collision_no;
        }
    };
} // namespace DL
